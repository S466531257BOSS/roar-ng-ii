#!/bin/sh

# include the roar-ng configuration file
if [ -f /etc/roar-ng.conf ]
then
	. /etc/roar-ng.conf
	INSTALL_PREFIX="/usr/share/roar-ng"
	VAR_PREFIX="/var/roar-ng"
	[ ! -d $VAR_PREFIX ] && mkdir "$VAR_PREFIX"
else
	# otherwise, if it doesn't exist, assume roar-ng runs from the sources
	# directory
	. ./roar-ng.conf
	INSTALL_PREFIX="$(pwd)"
	VAR_PREFIX="$INSTALL_PREFIX"
fi

#############
# constants #
#############

# the usage message
USAGE="Usage: roar-ng {check|setup|download|extract}
Build a GNU/Linux distribution.
"
# the current directory
BASE_DIR="$(pwd)"

# the default distribution
DEFAULT_DISTRO="subito"
DEFAULT_DISTRO_VERSION="2"
DEFAULT_DISTRO_ARCH="x86_64"

###########
# globals #
###########

# the current distribution
current_distro="$DEFAULT_DISTRO"
current_distro_version="$DEFAULT_DISTRO_VERSION"
current_distro_arch="$DEFAULT_DISTRO_ARCH"

# the package database file name
PACKAGE_DB_FILE_NAME="packages.txt"

#####################
# utility functions #
#####################

# download_file()
# purpose: downloads a file to a given path
# input  : a list of download URLs and the absolute destination path
# output : -
download_file() {
	# if aria2 is not present, use Wget
	if [ -z "$(which aria2c)" ]
	then
		wget -O "$2" "$(echo $1 | cut -f 1 -d \ )"
		[ 0 -ne $? ] && return 1
	else
		# otherwise, use aria2
		aria2c -d / \
			   -o "$2" \
			   --max-connection-per-server 4 \
			   --min-split-size 1M \
			   --split 4 \
			   $1
		[ 0 -ne $? ] && return 1
	fi

	return 0
}

# decompress_file()
# purpose: decompresses compressed files
# input  : a compressed file
# output : -
decompress_file() {
	# get the archive's MIME type
	file_type="$(file -bi "$1")"
	file_type="${file_type%%;*}"

	# choose the decompression tool
	case "$file_type" in
		application/x-gzip)
			tool="gzip"
			;;
		application/x-bzip2)
			tool="bzip2"
			;;
		application/x-xz)
			tool="xz"
			;;
		*)
			tool=""
	esac

	# if the file is unrecognized, do nothing
	[ -z "$tool" ] && return 0

	# otherwise, create a temporary file
	decompressed_file="$(mktemp -u)"

	# decompress the file
	$tool -c -d "$1" > $decompressed_file
	if [ 0 -ne $? ]
	then
		rm -f $decompressed_file
		return 1
	fi

	# override the file with the decompressed one
	mv -f $decompressed_file "$1"
	[ 0 -ne $? ] && return 1

	return 0
}

# extract_tar()
# purpose: extracts a tar archive
# input  : the archive path and a destination directory
# output : -
extract_tar() {
	# check whether the tar archive is compressed - if yes, decompress it
	decompress_file "$1"
	[ 0 -ne $? ] && return 1

	# extract the archive
	tar -xf "$1" -C "$2"
	[ 0 -ne $? ] && return 1

	return 0
}

###################################
# distribution switching routines #
###################################

# get_current_distro()
# purpose: returns the current distribution's name
# input  : -
# output : the current distribution's name
get_current_distro() {
	echo "$current_distro"
}

# get_current_distro_version()
# purpose: returns the current distribution's version
# input  : -
# output : the current distribution's version
get_current_distro_version() {
	echo "$current_distro_version"
}

# get_current_distro_arch()
# purpose: returns the current distribution's architecture
# input  : -
# output : the current distribution's architecture
get_current_distro_arch() {
	echo "$current_distro_arch"
}

# _load_distro_support_plug_in()
# purpose: loads a distribution support plug-in
# input  : the distribution name
# output : -
_load_distro_support_plug_in() {
	cd "$INSTALL_PREFIX/distro"
	[ ! -f "./$1" ] && return 1
	. "./$1"
	cd "$BASE_DIR"

	return 0
}

# set_current_distro()
# purpose: changes the current distribution
# input  : the distribution name, version and architecture
# output : -
set_current_distro() {
	# set the current distribution name and version
	current_distro="$1"
	current_distro_version="$2"

	# load the distribution support plug-in
	_load_distro_support_plug_in "$current_distro"
	[ 0 -ne $? ] && return 1

	# set the distribution architecture to the most accurate alias
	current_distro_arch="$(get_architecture_aliases $3)"
	[ -z "$current_distro_arch" ] && return 1
	current_distro_arch="${current_distro_arch%% *}"

	# reload the distribution's plugin, since it may rely on the set parameters
	# (e.g the architecture, in package list URLs)
	_load_distro_support_plug_in "$current_distro"

	return 0
}

# get_architecture_aliases()
# purpose: translates an architecture name to the distribution's nicknames
# input  : an architecture name
# output : the distribution's names for the architecture, ordered by accuracy
get_architecture_aliases() {
	 $(get_current_distro)_get_architecture_aliases $1
}

# download_package_list()
# purpose: downloads the distribution's package list
# input  : the package list URL and the destination path
# output : -
download_package_list() {
	$(get_current_distro)_download_package_list "$1" "$2"
}

# convert_package_list()
# purpose: converts a repository's package list to roar-ng's common format
# input  : the package list path and the repository name
# output : a package list in roar-ng's format
convert_package_list() {
	$(get_current_distro)_convert_package_list "$1" $2
}

# extract_package()
# purpose: extracts a package of the distribution into a directory
# input  : a package path and the destination directory
# output : -
extract_package() {
	$(get_current_distro)_extract_package "$1" "$2"
}

##############################################
# distribution information querying routines #
##############################################

# get_repository_names()
# purpose: returns all repository names
# input  : -
# output : a list of repository names
get_repository_names() {
	for repository in $REPOSITORIES
	do
		echo "${repository##*|}"
	done
}

# get_repository_package_list_url()
# purpose: returns the package list URL for a given repository
# input  : a repository name
# output : the repository's package list URL
get_repository_package_list_url() {
	for repository in $REPOSITORIES
	do
		[ "${repository##*|}" != "$1" ] && continue
		echo "${repository%%|*}"
		break
	done
}

# get_repository_mirrors()
# purpose: retrieves the mirrors list
# input  : -
# output : the repository mirrors list
get_repository_mirrors() {
	echo "$MIRRORS"
}

#############################
# package database routines #
#############################

# _get_package_database_path()
# purpose: returns the path to the package database
# input  : -
# output : the package database path
_get_package_database_path() {
	echo "$VAR_PREFIX/$PACKAGE_DB_FILE_NAME"
}

# initialize_package_database()
# purpose: creates an empty package database
# input  : -
# output : -
initialize_package_database() {
	# create an empty file
	echo -n "" > "$(_get_package_database_path)"
	return 0
}

# add_entries_to_package_database()
# purpose: adds package entries to the package database
# input  : package entries in list format, delimeted by "|" characters
# output : -
add_entries_to_package_database() {
	cat >> "$(_get_package_database_path)"
}

# get_package_entries()
# purpose: locates package entries by name, architecture and repository
# input  : the package name, architecture and repository
# output : matching package entries
get_package_entries() {
	awk -v name="$1" \
	    -v arch="$2" \
	    -v repo="$3" \
	    -v distro_version="$(get_current_distro_version)" \
	    -F \| '{
	            	if (name == $1 &&
	            	    arch == $4 &&
	            	    distro_version == $8 &&
	            	    repo == $9)
	            		print
	           }' "$(_get_package_database_path)"
}

##########################
# package entry routines #
##########################

# get_package_path()
# purpose: returns a package's path within a repository
# input  : a package entry
# output : the package path field
get_package_path() {
	echo "$1" | cut -f 5 -d \|
}

# get_package_file_name()
# purpose: returns a package's base file name
# input  : a package entry
# output : the package base file name
get_package_file_name() {
	package_path="$(get_package_path "$1")"
	echo "${package_path##*/}"
}

# get_package_repository()
# purpose: returns a package's repository
# input  : a package entry
# output : the package repository field
get_package_repository() {
	echo "${1##*|}"
}

#########################
# package list routines #
#########################

# get_package_list()
# purpose: returns the package list
# input  : -
# output : the package list
get_package_list() {
	# filter comments and empty lines
	echo "$DISTRO_PACKAGES" | grep -v -e ^# -e ^\$ | sort
}

# get_meta_package_name()
# purpose: returns the name field of a meta-package entry
# input  : a meta-package entry
# output : the meta package name
get_meta_package_name() {
	echo "${1%%|*}"
}

# get_meta_package_distro()
# purpose: receives a meta-package entry and returns the distribution fields
# input  :  a meta-package entry
# output : the distribution name, version and architecture
get_meta_package_distro() {
	echo "$1" | cut -f 3-5 -d \| | sed s/\|/\ /g
}

# get_meta_package_packages()
# purpose: lists the packages contained in a meta-package
# input  : a meta-package entry
# output : a list of the packages contained within the meta-package
get_meta_package_packages() {
	echo "$1" | cut -f 2 -d \| | sed s/,/\ /g
}

# get_used_distros()
# purpose: determines which distributions are used in the package list
# input  : -
# output : a list of distributions (name, version and architecture) used in the
#          package list
get_used_distros() {
	# do not use get_meta_package_distro() - invoking both cut and sed is slow
	get_package_list | awk -F \| '{print $3" "$4" "$5}' | sort | uniq
}

#########################
# repository processing #
#########################

# _add_repository_to_package_database()
# purpose: downloads a repository's package list and adds all package entries to
#          the package database
# input  : the repository name
# output : -
_add_repository_to_package_database() {
	# get the package list URL
	url="$(get_repository_package_list_url $1)"
	[ -z "$url" ] && return 1

	# create a temporary file
	package_list="$(mktemp -u)"

	# download the package list
	download_package_list "$url" "$package_list"
	[ 0 -ne $? ] && return 1

	# convert the package list to the common format, then add all entries to
	# the package database
	convert_package_list "$package_list" $1	| \
	sort | \
	add_entries_to_package_database

	# clean up
	rm -f "$package_list"
	[ 0 -ne $? ] && return 1

	return 0
}
# _add_distro_to_package_database()
# purpose: adds all package lists of the current distribution's repositories to
#          the package database
# input  : -
# output : -
_add_distro_to_package_database() {
	for repository in $(get_repository_names)
	do
		_add_repository_to_package_database $repository
		[ 0 -ne $? ] && return 1
	done
	return 0
}

# add_distros_to_package_database()
# purpose: downloads and processes the package lists of all repositories, for
#          each used distribution
# input  : -
# output : -
add_distros_to_package_database() {
	# create an empty package database
	initialize_package_database
	[ 0 -ne $? ] && return 1

	get_used_distros | while read distro
	do
		# set the current distribution
		set_current_distro $distro
		[ 0 -ne $? ] && return 1

		echo $distro $(get_current_distro_arch)

		# process the distribution's repositories
		_add_distro_to_package_database
		[ 0 -ne $? ] && return 1
	done

	return 0
}

##################
# package search #
##################

# find_package()
# purpose: the interface for searching the package database; finds the most
#          appropriate package entry
# input  : a package name
# output : the most appropriate entry for the package
find_package() {
	repositories="$(get_repository_names)"
	architectures="$(get_architecture_aliases $(get_current_distro_arch))"

	# try each repository, using all architecture aliases
	for repository in $repositories
	do
		for architecture in $architectures
		do
			result="$(get_package_entries $1 \
			                              $architecture \
			                              $repository)"
			[ -z "$result" ] && continue
			echo "$result" | tail -n 1
			return
		done
	done
}

###############################
# configuration sanity checks #
###############################

# verify_configuration()
# purpose: verifies that the configuration is sane
# input  : -
# output : -
verify_configuration() {
	get_used_distros | while read distro
	do
		# set the current distribution
		set_current_distro $distro
		[ 0 -ne $? ]  && return 1
	done

	return 0
}

####################
# package download #
####################

# _get_mirrors_for_repository()
# purpose: returns a list of all mirrors for a given repository
# input  : a repository name
# output : a list of mirror URLs
_get_mirrors_for_repository() {
	# for each mirror, filter the mirror URL and the list of repositories it
	# mirrors
	for mirror in $(get_repository_mirrors)
	do
		url="${mirror%%|*}"
		repositories="${mirror##*|}"

		# if the repository is mirrored, print the mirror URL
		for repository in $(echo $repositories | sed s/,/\ /g)
		do
			[ "$repository" != "$1" ] && continue
			echo "$url"
			break
		done
	done
}

# _get_package_download_url()
# purpose: returns download URLs for a given package
# input  : a package entry
# output : download URLs for the package
_get_package_download_url() {
	# get the package path within a repository
	package_path="$(get_package_path "$1")"

	# get the repository the package came from
	package_repository="$(get_package_repository "$1")"

	# for each mirror of the package's repository, create a full URL
	for mirror in $(_get_mirrors_for_repository $package_repository)
	do
		echo "$mirror/$package_path"
	done
}

# download_package()
# purpose: downloads a package
# input  : the package name
# output : -
download_package() {
	# locate the package entry
	package_entry="$(find_package $1)"
	[ -z "$package_entry" ] && return 1

	# filter the package's base file name
	package_file_name="$(get_package_file_name "$package_entry")"

	# if the package exists already, do nothing
	[ -f "$VAR_PREFIX/package/$package_file_name" ] && return 0

	# otherwise, download the package
	[ ! -d "$VAR_PREFIX/package" ] && mkdir "$VAR_PREFIX/package"
	download_file "$(_get_package_download_url "$package_entry")" \
	              "$VAR_PREFIX/package/$package_file_name"
	return $?
}

# download_packages()
# purpose: a wrapper around download_package() which downloads all packages
#          specified in the package list
# input  : -
# output : -
download_packages() {
	# for each meta-package, switch to its distribution and download all
	# packages
	get_package_list | while read entry
	do
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# download the packages
		for package in $packages
		do
			echo "$package"
			download_package $package
			[ 0 -ne $? ] && return 1
		done
	done

	return 0
}

######################
# package extraction #
######################

# extract_packages()
# purpose: a wrapper around extract_package() which extracts all packages
#          downloaded by download_packages()
# input  : -
# output : -
extract_packages() {
	get_package_list | while read entry
	do
		# get the meta-package name
		name="$(get_meta_package_name "$entry")"

		echo "$name"

		# get the meta-package's source distribution and the packages
		# contained in it
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# make sure the output directory is empty
		if [ -d "$VAR_PREFIX/extracted_package/$name" ]
		then
			rm -rf "$VAR_PREFIX/extracted_package/$name"/*
		else
			mkdir -p "$VAR_PREFIX/extracted_package/$name"
		fi

		# extract all packages
		for package in $packages
		do
			echo "  $package"

			# locate the package
			entry="$(find_package $package)"
			[ -z "$entry" ] && return 1

			# filter the package base file name
			file_name="$(get_package_file_name "$entry")"

			# extract the package
			extract_package "$VAR_PREFIX/package/$file_name" \
			                "$VAR_PREFIX/extracted_package/$name"
			[ 0 -ne $? ] && return 1
		done
	done

	return 0
}

case "$1" in
	check)
		verify_configuration
		exit $?
		;;

	setup)
		add_distros_to_package_database
		exit $?
		;;

	download)
		download_packages
		exit $?
		;;

	extract)
		extract_packages
		exit $?
		;;

	*)
		echo "$USAGE"
		exit 1
		;;
esac
