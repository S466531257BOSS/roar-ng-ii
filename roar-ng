#!/bin/sh

##############################
# installation path handling #
##############################

# determine where roar-ng runs from - if the configuration file exists in its
# normal location, roar-ng is installed
if [ -f "/$CONFIGURATION_INSTALL_PATH" ]
then
	INSTALL_PREFIX="/usr/share/roar-ng"
	VAR_PREFIX="/var/roar-ng"
	CONFIGURATION_PATH="/$CONFIGURATION_INSTALL_PATH"
else
	# otherwise, if it doesn't exist, assume roar-ng runs from the sources
	# directory
	INSTALL_PREFIX="$(pwd)"
	VAR_PREFIX="$INSTALL_PREFIX/sandbox"
	CONFIGURATION_PATH="$INSTALL_PREFIX/roar-ng.conf"
fi

##################
# initialization #
##################

# create the variable data directory
[ ! -d "$VAR_PREFIX" ] && mkdir "$VAR_PREFIX"

# include the roar-ng configuration file
. "$CONFIGURATION_PATH"

#############
# constants #
#############

# the usage message
USAGE="Usage: roar-ng {check|setup|download|extract|build} [TYPE]
Build a GNU/Linux distribution.

Supported bootable media types: $(ls -1 $INSTALL_PREFIX/media | tr '\n' ' ')
"

# the current directory
BASE_DIR="$(pwd)"

# the default distribution
DEFAULT_DISTRO="subito"
DEFAULT_DISTRO_VERSION="2"
DEFAULT_DISTRO_ARCH="x86_64"

##################
# package choice #
##################

# must-have packages for the initramfs
INITRAMFS_PACKAGES="busybox"

#########
# paths #
#########

# the package database file name
PACKAGE_DB_FILE_NAME="packages.txt"

# the package templates hacks script file name
PACKAGE_TEMPLATE_HACKS_FILE_NAME="hacks.sh"

# the kernel image path
KERNEL_IMAGE_PATH="boot/vmlinuz"

# the initramfs file name
INITRAMFS_FILE_NAME="initrd.gz"

# the root file system image file name
ROOT_FS_FILE_NAME="rootfs.sfs"

# the package post-installation script name
POST_INSTALL_SCRIPT_FILE_NAME="post_install.sh"

# the roar-ng configuration file path, when roar-ng is installed as a package
CONFIGURATION_INSTALL_PATH="etc/roar-ng.conf"

###########
# options #
###########

# the mksquashfs flags used
MKSQUASHFS_OPTIONS="-comp xz -Xbcj x86 -b 524288 -no-exports"

# the gzip flags used to compress the initramfs
GZIP_OPTIONS="--best"

###########
# globals #
###########

# the current distribution
current_distro="$DEFAULT_DISTRO"
current_distro_version="$DEFAULT_DISTRO_VERSION"
current_distro_arch="$DEFAULT_DISTRO_ARCH"

#####################
# utility functions #
#####################

# download_file()
# purpose: downloads a file to a given path
# input  : a list of download URLs and the absolute destination path
# output : -
download_file() {
	# if aria2 is not present, use Wget
	if [ -z "$(which aria2c)" ]
	then
		wget -O "$2" "$(echo $1 | cut -f 1 -d \ )"
		[ 0 -ne $? ] && return 1
	else
		# otherwise, use aria2
		aria2c -d / \
			   -o "$2" \
			   --file-allocation none \
			   --max-connection-per-server 4 \
			   --min-split-size 1M \
			   --split 4 \
			   $1
		[ 0 -ne $? ] && return 1
	fi

	return 0
}

# decompress_file()
# purpose: decompresses compressed files
# input  : a compressed file
# output : -
decompress_file() {
	# get the archive's MIME type
	file_type="$(file -bi "$1")"
	file_type="${file_type%%;*}"

	# choose the decompression tool
	case "$file_type" in
		application/x-gzip)
			tool="gzip"
			;;
		application/x-bzip2)
			tool="bzip2"
			;;
		application/x-xz)
			tool="xz"
			;;
		*)
			tool=""
	esac

	# if the file is unrecognized, do nothing
	[ -z "$tool" ] && return 0

	# otherwise, create a temporary file
	decompressed_file="$(mktemp -u)"

	# decompress the file
	$tool -c -d "$1" > $decompressed_file
	if [ 0 -ne $? ]
	then
		rm -f $decompressed_file
		return 1
	fi

	# override the file with the decompressed one
	mv -f $decompressed_file "$1"
	[ 0 -ne $? ] && return 1

	return 0
}

# extract_tar()
# purpose: extracts a tar archive
# input  : the archive path and a destination directory
# output : -
extract_tar() {
	# check whether the tar archive is compressed - if yes, decompress it
	decompress_file "$1"
	[ 0 -ne $? ] && return 1

	# extract the archive
	tar -xf "$1" -C "$2"
	[ 0 -ne $? ] && return 1

	return 0
}

# execute_and_delete_script()
# purpose: executes a script in its directory and deletes it
# input  : the script path
# output : -
execute_and_delete_script() {
	# make the script executable
	chmod 755 "$1"

	# switch to the script's directory and run it
	cd "$(dirname "$1")"
	"$1"
	cd "$BASE_DIR"

	# delete the script
	rm -f "$1"
	[ 0 -ne $? ] && return 1

	return 0
}

###################################
# distribution switching routines #
###################################

# get_current_distro()
# purpose: returns the current distribution's name
# input  : -
# output : the current distribution's name
get_current_distro() {
	echo "$current_distro"
}

# get_current_distro_version()
# purpose: returns the current distribution's version
# input  : -
# output : the current distribution's version
get_current_distro_version() {
	echo "$current_distro_version"
}

# get_current_distro_arch()
# purpose: returns the current distribution's architecture
# input  : -
# output : the current distribution's architecture
get_current_distro_arch() {
	echo "$current_distro_arch"
}

# _load_distro_support_plug_in()
# purpose: loads a distribution support plug-in
# input  : the distribution name
# output : -
_load_distro_support_plug_in() {
	cd "$INSTALL_PREFIX/distro"
	[ ! -f "./$1" ] && return 1
	. "./$1"
	cd "$BASE_DIR"

	return 0
}

# set_current_distro()
# purpose: changes the current distribution
# input  : the distribution name, version and architecture
# output : -
set_current_distro() {
	# set the current distribution name and version
	current_distro="$1"
	current_distro_version="$2"

	# load the distribution support plug-in
	_load_distro_support_plug_in "$current_distro"
	[ 0 -ne $? ] && return 1

	# set the distribution architecture to the most accurate alias
	current_distro_arch="$(get_architecture_aliases $3)"
	[ -z "$current_distro_arch" ] && return 1
	current_distro_arch="${current_distro_arch%% *}"

	# reload the distribution's plugin, since it may rely on the set parameters
	# (e.g the architecture, in package list URLs)
	_load_distro_support_plug_in "$current_distro"

	return 0
}

# get_architecture_aliases()
# purpose: translates an architecture name to the distribution's nicknames
# input  : an architecture name
# output : the distribution's names for the architecture, ordered by accuracy
get_architecture_aliases() {
	 $(get_current_distro)_get_architecture_aliases $1
}

# download_package_list()
# purpose: downloads the distribution's package list
# input  : the package list URL and the destination path
# output : -
download_package_list() {
	$(get_current_distro)_download_package_list "$1" "$2"
}

# convert_package_list()
# purpose: converts a repository's package list to roar-ng's common format
# input  : the package list path and the repository name
# output : a package list in roar-ng's format
convert_package_list() {
	$(get_current_distro)_convert_package_list "$1" $2
}

# extract_package()
# purpose: extracts a package of the distribution into a directory
# input  : a package path and the destination directory
# output : -
extract_package() {
	$(get_current_distro)_extract_package "$1" "$2"
}

##############################################
# distribution information querying routines #
##############################################

# get_repository_names()
# purpose: returns all repository names
# input  : -
# output : a list of repository names
get_repository_names() {
	for repository in $REPOSITORIES
	do
		echo "${repository##*|}"
	done
}

# get_repository_package_list_url()
# purpose: returns the package list URL for a given repository
# input  : a repository name
# output : the repository's package list URL
get_repository_package_list_url() {
	for repository in $REPOSITORIES
	do
		[ "${repository##*|}" != "$1" ] && continue
		echo "${repository%%|*}"
		break
	done
}

# get_repository_mirrors()
# purpose: retrieves the mirrors list
# input  : -
# output : the repository mirrors list
get_repository_mirrors() {
	echo "$MIRRORS"
}

#############################
# package database routines #
#############################

# _get_package_database_path()
# purpose: returns the path to the package database
# input  : -
# output : the package database path
_get_package_database_path() {
	echo "$VAR_PREFIX/$PACKAGE_DB_FILE_NAME"
}

# initialize_package_database()
# purpose: creates an empty package database
# input  : -
# output : -
initialize_package_database() {
	# create an empty file
	echo -n "" > "$(_get_package_database_path)"
	return 0
}

# add_entries_to_package_database()
# purpose: adds package entries to the package database
# input  : package entries in list format, delimeted by "|" characters
# output : -
add_entries_to_package_database() {
	cat >> "$(_get_package_database_path)"
}

# get_package_entries()
# purpose: locates package entries by name, architecture and repository
# input  : the package name, architecture and repository
# output : matching package entries
get_package_entries() {
	awk -v name="$1" \
	    -v arch="$2" \
	    -v repo="$3" \
	    -v distro_version="$(get_current_distro_version)" \
	    -F \| '{
	            	if (name == $1 &&
	            	    arch == $4 &&
	            	    distro_version == $8 &&
	            	    repo == $9)
	            		print
	           }' "$(_get_package_database_path)"
}

##########################
# package entry routines #
##########################

# get_package_path()
# purpose: returns a package's path within a repository
# input  : a package entry
# output : the package path field
get_package_path() {
	echo "$1" | cut -f 5 -d \|
}

# get_package_file_name()
# purpose: returns a package's base file name
# input  : a package entry
# output : the package base file name
get_package_file_name() {
	package_path="$(get_package_path "$1")"
	echo "${package_path##*/}"
}

# get_package_repository()
# purpose: returns a package's repository
# input  : a package entry
# output : the package repository field
get_package_repository() {
	echo "${1##*|}"
}

#########################
# package list routines #
#########################

# get_package_list()
# purpose: returns the package list
# input  : -
# output : the package list
get_package_list() {
	# filter comments and empty lines
	echo "$DISTRO_PACKAGES" | grep -v -e ^# -e ^\$
}

# get_meta_package_name()
# purpose: returns the name field of a meta-package entry
# input  : a meta-package entry
# output : the meta package name
get_meta_package_name() {
	echo "${1%%|*}"
}

# get_meta_package_names()
# purpose: returns all meta-package names
# input  : -
# output : all meta package names
get_meta_package_names() {
	get_package_list | cut -f 1 -d \|
}
# get_meta_package_distro()
# purpose: receives a meta-package entry and returns the distribution fields
# input  :  a meta-package entry
# output : the distribution name, version and architecture
get_meta_package_distro() {
	echo "$1" | cut -f 3-5 -d \| | sed s/\|/\ /g
}

# get_meta_package_packages()
# purpose: lists the packages contained in a meta-package
# input  : a meta-package entry
# output : a list of the packages contained within the meta-package
get_meta_package_packages() {
	echo "$1" | cut -f 2 -d \| | sed s/,/\ /g
}

# get_used_distros()
# purpose: determines which distributions are used in the package list
# input  : -
# output : a list of distributions (name, version and architecture) used in the
#          package list
get_used_distros() {
	# do not use get_meta_package_distro() - invoking both cut and sed is slow
	get_package_list | awk -F \| '{print $3" "$4" "$5}' | sort | uniq
}

#########################
# repository processing #
#########################

# _add_repository_to_package_database()
# purpose: downloads a repository's package list and adds all package entries to
#          the package database
# input  : the repository name
# output : -
_add_repository_to_package_database() {
	# get the package list URL
	url="$(get_repository_package_list_url $1)"
	[ -z "$url" ] && return 1

	# create a temporary file
	package_list="$(mktemp -u)"

	# download the package list
	download_package_list "$url" "$package_list"
	[ 0 -ne $? ] && return 1

	# convert the package list to the common format, then add all entries to
	# the package database
	convert_package_list "$package_list" $1	| \
	sort | \
	add_entries_to_package_database

	# clean up
	rm -f "$package_list"
	[ 0 -ne $? ] && return 1

	return 0
}
# _add_distro_to_package_database()
# purpose: adds all package lists of the current distribution's repositories to
#          the package database
# input  : -
# output : -
_add_distro_to_package_database() {
	for repository in $(get_repository_names)
	do
		_add_repository_to_package_database $repository
		[ 0 -ne $? ] && return 1
	done
	return 0
}

# add_distros_to_package_database()
# purpose: downloads and processes the package lists of all repositories, for
#          each used distribution
# input  : -
# output : -
add_distros_to_package_database() {
	# create an empty package database
	initialize_package_database
	[ 0 -ne $? ] && return 1

	get_used_distros | while read distro
	do
		echo "$distro"

		# set the current distribution
		set_current_distro $distro
		[ 0 -ne $? ] && return 1

		# process the distribution's repositories
		_add_distro_to_package_database
		[ 0 -ne $? ] && return 1
	done

	return 0
}

##################
# package search #
##################

# find_package()
# purpose: the interface for searching the package database; finds the most
#          appropriate package entry
# input  : a package name
# output : the most appropriate entry for the package
find_package() {
	repositories="$(get_repository_names)"
	architectures="$(get_architecture_aliases $(get_current_distro_arch))"

	# try each repository, using all architecture aliases
	for repository in $repositories
	do
		for architecture in $architectures
		do
			result="$(get_package_entries $1 \
			                              $architecture \
			                              $repository)"
			[ -z "$result" ] && continue
			echo "$result" | tail -n 1
			return
		done
	done
}

###############################
# configuration sanity checks #
###############################

# verify_configuration()
# purpose: verifies that the configuration is sane
# input  : -
# output : -
verify_configuration() {
	get_used_distros | while read distro
	do
		# set the current distribution
		set_current_distro $distro
		[ 0 -ne $? ]  && return 1
	done

	return 0
}

####################
# package download #
####################

# _get_mirrors_for_repository()
# purpose: returns a list of all mirrors for a given repository
# input  : a repository name
# output : a list of mirror URLs
_get_mirrors_for_repository() {
	# for each mirror, filter the mirror URL and the list of repositories it
	# mirrors
	for mirror in $(get_repository_mirrors)
	do
		url="${mirror%%|*}"
		repositories="${mirror##*|}"

		# if the repository is mirrored, print the mirror URL
		for repository in $(echo $repositories | sed s/,/\ /g)
		do
			[ "$repository" != "$1" ] && continue
			echo "$url"
			break
		done
	done
}

# _get_package_download_url()
# purpose: returns download URLs for a given package
# input  : a package entry
# output : download URLs for the package
_get_package_download_url() {
	# get the package path within a repository
	package_path="$(get_package_path "$1")"

	# get the repository the package came from
	package_repository="$(get_package_repository "$1")"

	# for each mirror of the package's repository, create a full URL
	for mirror in $(_get_mirrors_for_repository $package_repository)
	do
		echo "$mirror/$package_path"
	done
}

# download_package()
# purpose: downloads a package
# input  : the package name
# output : -
download_package() {
	# locate the package entry
	package_entry="$(find_package $1)"
	[ -z "$package_entry" ] && return 1

	# filter the package's base file name
	package_file_name="$(get_package_file_name "$package_entry")"

	# if the package exists already, do nothing
	[ -f "$VAR_PREFIX/package/$package_file_name" ] && return 0

	# otherwise, download the package
	[ ! -d "$VAR_PREFIX/package" ] && mkdir "$VAR_PREFIX/package"
	download_file "$(_get_package_download_url "$package_entry")" \
	              "$VAR_PREFIX/package/$package_file_name"
	return $?
}

# download_packages()
# purpose: a wrapper around download_package() which downloads all packages
#          specified in the package list
# input  : -
# output : -
download_packages() {
	# for each meta-package, switch to its distribution and download all
	# packages
	get_package_list | while read entry
	do
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# download the packages
		for package in $packages
		do
			echo "$package"
			download_package $package
			[ 0 -ne $? ] && return 1
		done
	done

	return 0
}

######################
# package extraction #
######################

# _apply_package_template()
# purpose: applies a package template on an extracted package
# input  : a package name and the path to the extracted package contents
#          directory
# output : -
_apply_package_template() {
	# if no package template exists, do nothing
	[ ! -d "$INSTALL_PREFIX/package-templates/$1" ] && return 0

	echo "  applying $INSTALL_PREFIX/package-templates/$1"

	# otherwise, copy the package template into the extracted package directory
	cp -ar "$INSTALL_PREFIX/package-templates/$1"/* "$2"
	[ 0 -ne $? ] && return 1

	# if a hacks script exists, run it
	[ ! -f "$2/$PACKAGE_TEMPLATE_HACKS_FILE_NAME" ] && return 0
	execute_and_delete_script "$2/$PACKAGE_TEMPLATE_HACKS_FILE_NAME"
	return $?
}

# extract_packages()
# purpose: a wrapper around extract_package() which extracts all packages
#          downloaded by download_packages()
# input  : -
# output : -
extract_packages() {
	get_package_list | while read entry
	do
		# get the meta-package name
		name="$(get_meta_package_name "$entry")"

		echo "$name"

		# get the meta-package's source distribution and the packages
		# contained in it
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# if the output directory exists, skip the meta-package
		[ -d "$VAR_PREFIX/extracted_package/$name" ] && continue

		# otherwise, create it
		mkdir -p "$VAR_PREFIX/extracted_package/$name"
		[ 0 -ne $? ] && return 1

		# extract all packages
		for package in $packages
		do
			echo "  $package"

			# locate the package
			entry="$(find_package $package)"
			[ -z "$entry" ] && return 1

			# filter the package base file name
			file_name="$(get_package_file_name "$entry")"

			# extract the package
			extract_package "$VAR_PREFIX/package/$file_name" \
			                "$VAR_PREFIX/extracted_package/$name"
			[ 0 -ne $? ] && return 1
		done

		# apply the package template, if there is any
		_apply_package_template $name "$VAR_PREFIX/extracted_package/$name"
		[ 0 -ne $? ] && return 1
	done

	return 0
}

#####################################
# bootable media image construction #
#####################################

# _build_module()
# purpose: builds a module of the bootable media image
# input  : the module name, destination directory and the list of packages
# output : -
_build_module() {
	echo "$1"

	# create the destination directory
	if [ ! -d "$2" ]
	then
		mkdir "$2"
		[ 0 -ne $? ] && return 1
	fi

	# create a temporary file which will contain the post-installation script
	post_install="$(mktemp -u -p "$2")"

	(
		# create a list of all package directories
		for package in $3
		do
			echo "$VAR_PREFIX/extracted_package/$package"
		done

		# append the module's skeleton
		echo "$INSTALL_PREFIX/skeleton/$1"
	) | while read path
	do
		echo "  $path"

		# copy the contents of each directory to the destination
		cp -a --remove-destination "$path"/* "$2"
		[ 0 -ne $? ] && return 1

		# if a post-installation script exists, merge it with the previous ones
		[ ! -f "$2/$POST_INSTALL_SCRIPT_FILE_NAME" ] && continue
		cat "$2/$POST_INSTALL_SCRIPT_FILE_NAME" >> "$post_install"
		rm -f "$2/$POST_INSTALL_SCRIPT_FILE_NAME"
		[ 0 -ne $? ] && return 1
	done

	# if at least one post-installation script exists, run it
	[ ! -f "$post_install" ] && return 0
	execute_and_delete_script "$post_install"
	return $?
}

# _build_initramfs()
# purpose: builds the initramfs
# input  : the extracted initramfs contents directory and the destination path
# output : -
_build_initramfs() {
	# copy the initramfs packages and skeleton
	_build_module "initramfs" "$1" "$INITRAMFS_PACKAGES"
	[ 0 -ne $? ] && return 1

	# create and compress the initramfs
	cd "$1"
	find . | cpio -o -H newc | gzip $GZIP_OPTIONS > "$2"
	exit_code=$?
	cd "$BASE_DIR"
	[ 0 -ne $exit_code ] && return 1

	# if AdvanceCOMP is installed, recompress the initramfs
	[ -z "$(which advdef)" ] && return 0
	advdef -z4 "$2"
	[ 0 -ne $? ] && return 1

	return 0
}

# _build_rootfs()
# purpose: builds the root file system Squashfs image
# input  : the extracted root file system contents directory and the destination
#          path
# output : -
_build_rootfs() {
	# copy roar-ng's configuration to the root file system
	install -D -m 644 "$CONFIGURATION_PATH" "$1/$CONFIGURATION_INSTALL_PATH"
	[ 0 -ne $? ] && return 1

	# copy the root file system packages and skeleton
	_build_module "rootfs" "$1" "$(get_meta_package_names)"
	[ 0 -ne $? ] && return 1

	# create /etc/hostname
	echo -n "$DISTRO_NICKNAME" > "$1/etc/hostname"

	# replace DISTRO_NAME and DISTRO_VERSION with their values, in /etc/issue
	# and /etc/motd
	for i in issue motd
	do
		sed -e s~DISTRO_NAME~"$DISTRO_NAME"~g \
		    -e s~DISTRO_VERSION~"$DISTRO_VERSION"~g \
		    -i "$1/etc/$i"
	done

	# create a Squashfs image
	mksquashfs "$1" "$2" $MKSQUASHFS_OPTIONS
	[ 0 -ne $? ] && return 1

	return 0
}

# build_bootable_media_image()
# purpose: builds a bootable media image
# input  : the bootable media type
# output : -
build_bootable_media_image() {
	# make sure the given media is supported
	[ ! -f "$INSTALL_PREFIX/media/$1" ] && return 1

	# create a root directory for the bootable media contents
	if [ -d "$VAR_PREFIX/media" ]
	then
		rm -rf "$VAR_PREFIX/media"/*
		[ 0 -ne $? ] && return 1
	else
		mkdir "$VAR_PREFIX/media"
		[ 0 -ne $? ] && return 1
	fi

	# create /boot
	mkdir "$VAR_PREFIX/media/boot"
	[ 0 -ne $? ] && return 1

	# build the initramfs
	_build_initramfs "$VAR_PREFIX/initramfs" \
	                 "$VAR_PREFIX/media/boot/$INITRAMFS_FILE_NAME"
	[ 0 -ne $? ] && return 1

	# build the root file system image
	_build_rootfs "$VAR_PREFIX/rootfs" \
	              "$VAR_PREFIX/media/boot/$ROOT_FS_FILE_NAME"
	[ 0 -ne $? ] && return 1

	# move the kernel image from the root file system to the media itself
	mv -f "$VAR_PREFIX/rootfs/$KERNEL_IMAGE_PATH" \
	      "$VAR_PREFIX/media/$KERNEL_IMAGE_PATH"

	# build a bootable media image
	. "$INSTALL_PREFIX/media/$1"
	build_media_$1
	[ 0 -ne $? ] && return 1

	return 0
}

# _show_usage()
# purpose: shows the usage message and exits
# input  : -
# output : -
_show_usage() {
	echo "$USAGE"
	exit 1
}

# roar_ng_main()
# purpose: runs roar-ng
# input  : -
# output : the command-line arguments the script was executed with
roar_ng_main() {
	case "$1" in
		check)
			[ 1 -ne $# ] && _show_usage
			verify_configuration
			exit $?
			;;

		setup)
			[ 1 -ne $# ] && _show_usage
			add_distros_to_package_database
			exit $?
			;;

		download)
			[ 1 -ne $# ] && _show_usage
			download_packages
			exit $?
			;;

		extract)
			[ 1 -ne $# ] && _show_usage
			extract_packages
			exit $?
			;;

		build)
			[ 2 -ne $# ] && _show_usage
			build_bootable_media_image "$2"
			exit $?
			;;

		*)
			_show_usage
			;;
	esac
}

# if the script was invoked as "roar-ng", run the script's main logic;
# otherwise, do nothing, to allow the script to be included in other scripts
case "$0" in
	roar-ng|*/roar-ng)
		roar_ng_main "$@"
		;;
esac
