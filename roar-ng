#!/bin/sh

##############################
# installation path handling #
##############################

# the roar-ng configuration file path, when roar-ng is installed as a package
CONFIGURATION_INSTALL_PATH="etc/roar-ng.conf"

# determine where roar-ng runs from - if the configuration file exists in its
# normal location, roar-ng is installed
if [ -f "/$CONFIGURATION_INSTALL_PATH" ] && [ ! -f roar-ng.conf ]
then
	INSTALL_PREFIX="/usr/share/roar-ng"
	VAR_PREFIX="/var/roar-ng"
	CONFIGURATION_PATH="/$CONFIGURATION_INSTALL_PATH"
else
	# otherwise, if it doesn't exist, assume roar-ng runs from the sources
	# directory
	INSTALL_PREFIX="$(pwd)"
	VAR_PREFIX="$INSTALL_PREFIX/sandbox"
	CONFIGURATION_PATH="$INSTALL_PREFIX/roar-ng.conf"
fi

##################
# initialization #
##################

# create the variable data directory
[ ! -d "$VAR_PREFIX" ] && mkdir "$VAR_PREFIX"

# include the roar-ng configuration file
. "$CONFIGURATION_PATH"

#############
# constants #
#############

# the usage message
USAGE="Usage: roar-ng {check|setup|download|extract|cleanup}
       roar-ng build TYPE DEST
       roar-ng package [NAME]

Build a GNU/Linux distribution.
"

# the current directory
BASE_DIR="$(pwd)"

# the default distribution
DEFAULT_DISTRO="subito"
DEFAULT_DISTRO_VERSION="2"
DEFAULT_DISTRO_ARCH="x86_64"

#########
# paths #
#########

# the package database file name
PACKAGE_DB_FILE_NAME="packages.txt"

# the package templates hacks script file name
PACKAGE_TEMPLATE_HACKS_FILE_NAME="hacks.sh"

# the BusyBox executable path
BUSYBOX_PATH="$VAR_PREFIX/rootfs/usr/bin/busybox"

# the kernel image path
KERNEL_IMAGE_PATH="boot/vmlinuz"

# the initramfs file name
INITRAMFS_FILE_NAME="initrd.gz"

# the root file system image file name
ROOT_FS_FILE_NAME="rootfs.sfs"

# the package post-installation script name
POST_INSTALL_SCRIPT_FILE_NAME="post_install.sh"

####################
# package building #
####################

# virtual file systems and directories to bind to the host's before calling
# chroot
CHROOT_VIRTUAL_FS="proc sys dev"

# files to copy into the chroot environment
CHROOT_FILES="etc/resolv.conf"

# the prefix for package building operations
BUILD_PREFIX="tmp"

# the prefix for package build results
BUILD_RESULT_PREFIX="usr/src"

###########
# options #
###########

# the mksquashfs flags used
MKSQUASHFS_OPTIONS="-comp xz -Xbcj x86 -b 512K -no-exports"

# the gzip flags used to compress the initramfs
GZIP_OPTIONS="--best"

###########
# globals #
###########

# the current distribution
current_distro="$DEFAULT_DISTRO"
current_distro_version="$DEFAULT_DISTRO_VERSION"
current_distro_arch="$DEFAULT_DISTRO_ARCH"

#####################
# utility functions #
#####################

# download_file()
# purpose: downloads a file to a given path
# input  : a list of download URLs and the destination path (optional)
# output : -
download_file() {
	# filter the first URL
	first_url="$(echo $1 | cut -f 1 -d \ )"

	# if no destination was specified, filter the base file name
	if [ -z "$2" ]
	then
		destination="${first_url##*/}"
	else
		destination="$2"
	fi

	# turn relative paths into absolute ones
	destination="$(realpath "$destination")"

	# if the destination exists already, do nothing and assume it's the right
	# file
	[ -f "$destination" ] && return 0

	# if aria2 is not present, use Wget
	if [ -z "$(which aria2c)" ]
	then
		wget --no-check-certificate -O "$destination" "$first_url"
		[ 0 -ne $? ] && return 1
	else
		# otherwise, use aria2
		aria2c -d / \
			   -o "$destination" \
			   --file-allocation none \
			   --max-connection-per-server 4 \
			   --min-split-size 1M \
			   --split 4 \
			   --check-certificate=false \
			   $1
		[ 0 -ne $? ] && return 1
	fi

	return 0
}

# decompress_file()
# purpose: decompresses compressed files
# input  : a compressed file and an optional output file path
# output : -
decompress_file() {
	# get the archive's MIME type
	file_type="$(file -bi "$1")"
	file_type="${file_type%%;*}"

	# choose the destination path
	if [ -z "$2" ]
	then
		destination="$1"
	else
		destination="$2"
	fi

	# choose the decompression tool
	case "$file_type" in
		application/x-gzip)
			tool="gzip"
			;;
		application/x-bzip2)
			tool="bzip2"
			;;
		application/x-xz)
			tool="xz"
			;;
		*)
			tool=""
	esac

	# if the file is unrecognized, do nothing
	[ -z "$tool" ] && return 0

	# otherwise, create a temporary file
	decompressed_file="$(mktemp -u)"

	# decompress the file
	$tool -c -d "$1" > $decompressed_file
	if [ 0 -ne $? ]
	then
		rm -f $decompressed_file
		return 1
	fi

	# move the decompressed file to the destination path
	mv -f $decompressed_file "$destination"
	[ 0 -ne $? ] && return 1

	return 0
}

# extract_tarball()
# purpose: extracts a tar archive
# input  : the archive path and a destination directory (optional)
# output : -
extract_tarball() {
	# check whether the tar archive is compressed - if yes, decompress it
	decompress_file "$1"
	[ 0 -ne $? ] && return 1

	# if no destination path was given, extract to the current directory
	if [ -z "$2" ]
	then
		destination="."
	else
		destination="$2"
	fi

	# extract the archive
	tar -xf "$1" -C "$destination"
	[ 0 -ne $? ] && return 1

	return 0
}

# execute_and_delete_script()
# purpose: executes a script in its directory and deletes it
# input  : the script path
# output : -
execute_and_delete_script() {
	# make the script executable
	chmod 755 "$1"

	# switch to the script's directory and run it
	cd "$(dirname "$1")"
	"$1"
	cd "$BASE_DIR"

	# delete the script
	rm -f "$1"
	[ 0 -ne $? ] && return 1

	return 0
}

# make_tarball()
# purpose: creates a compressed tarball from a directory
# input  : a directory path, the tarball path and an optional boolean which
#          indicates whether the parent directory should be kept (1 by default)
# output : -
make_tarball() {
	# make the directory path absolute
	directory="$(realpath "$1")"

	# determine whether the parent directory should be included; the default is
	# yes
	if [ -z "$3" ]
	then
		keep_parent=1
	else
		keep_parent="$3"
	fi

	# choose the parent directory for the tarball contents and the actual
	# contents
	if [ 1 -eq $keep_parent ]
	then
		parent="${directory%/*}"
		contents="${directory##*/}"
	else
		parent="$directory"
		contents="*"
	fi

	# make the output file path absolute
	destination="$(realpath "$2")"

	# create a compressed tarball from the directory
	cd "$parent"
	tar -c $contents | xz -e --best > "$destination"
	exit_code=$?
	cd "$BASE_DIR"
	[ 0 -ne $exit_code ] && return 1

	return 0
}

# make_tarball_and_delete()
# purpose: creates a compressed tarball from a directory and recursively deletes
#          it
# input  : see the documentation for make_tarball()
# output : -
make_tarball_and_delete() {
	# create the tarball
	make_tarball "$1" "$2" "$3"
	[ 0 -ne $exit_code ] && return 1

	# delete the directory
	rm -rf "$1"
	[ 0 -ne $exit_code ] && return 1

	return 0
}

# print_error()
# purpose: prints an error to the standard error output
# input  : an error message
# output : -
print_error() {
	echo "Error: $1." 1>&2
}

###################################
# distribution switching routines #
###################################

# get_current_distro()
# purpose: returns the current distribution's name
# input  : -
# output : the current distribution's name
get_current_distro() {
	echo "$current_distro"
}

# get_current_distro_version()
# purpose: returns the current distribution's version
# input  : -
# output : the current distribution's version
get_current_distro_version() {
	echo "$current_distro_version"
}

# get_current_distro_arch()
# purpose: returns the current distribution's architecture
# input  : -
# output : the current distribution's architecture
get_current_distro_arch() {
	echo "$current_distro_arch"
}

# _load_distro_support_plug_in()
# purpose: loads a distribution support plug-in
# input  : the distribution name
# output : -
_load_distro_support_plug_in() {
	cd "$INSTALL_PREFIX/distro"
	[ ! -f "./$1" ] && return 1
	. "./$1"
	cd "$BASE_DIR"

	return 0
}

# set_current_distro()
# purpose: changes the current distribution
# input  : the distribution name, version and architecture
# output : -
set_current_distro() {
	# set the current distribution name and version
	current_distro="$1"
	current_distro_version="$2"

	# load the distribution support plug-in
	_load_distro_support_plug_in "$current_distro"
	[ 0 -ne $? ] && return 1

	# set the distribution architecture to the most accurate alias
	current_distro_arch="$(get_architecture_aliases $3)"
	[ -z "$current_distro_arch" ] && return 1
	current_distro_arch="${current_distro_arch%% *}"

	# reload the distribution's plugin, since it may rely on the set parameters
	# (e.g the architecture, in package list URLs)
	_load_distro_support_plug_in "$current_distro"

	return 0
}

# get_architecture_aliases()
# purpose: translates an architecture name to the distribution's nicknames
# input  : an architecture name
# output : the distribution's names for the architecture, ordered by accuracy
get_architecture_aliases() {
	 $(get_current_distro)_get_architecture_aliases $1
}

# download_package_list()
# purpose: downloads the distribution's package list
# input  : the package list URL and the destination path
# output : -
download_package_list() {
	$(get_current_distro)_download_package_list "$1" "$2"
}

# convert_package_list()
# purpose: converts a repository's package list to roar-ng's common format
# input  : the package list path and the repository name
# output : a package list in roar-ng's format
convert_package_list() {
	$(get_current_distro)_convert_package_list "$1" $2
}

# extract_package()
# purpose: extracts a package of the distribution into a directory
# input  : a package path and the destination directory
# output : -
extract_package() {
	$(get_current_distro)_extract_package "$1" "$2"
}

##############################################
# distribution information querying routines #
##############################################

# get_repository_names()
# purpose: returns all repository names
# input  : -
# output : a list of repository names
get_repository_names() {
	for repository in $REPOSITORIES
	do
		echo "${repository##*|}"
	done
}

# get_repository_package_list_url()
# purpose: returns the package list URL for a given repository
# input  : a repository name
# output : the repository's package list URL
get_repository_package_list_url() {
	for repository in $REPOSITORIES
	do
		[ "${repository##*|}" != "$1" ] && continue
		echo "${repository%%|*}"
		break
	done
}

# get_repository_mirrors()
# purpose: retrieves the mirrors list
# input  : -
# output : the repository mirrors list
get_repository_mirrors() {
	echo "$MIRRORS"
}

#############################
# package database routines #
#############################

# _get_package_database_path()
# purpose: returns the path to the package database
# input  : -
# output : the package database path
_get_package_database_path() {
	echo "$VAR_PREFIX/$PACKAGE_DB_FILE_NAME"
}

# initialize_package_database()
# purpose: creates an empty package database
# input  : -
# output : -
initialize_package_database() {
	# create an empty file
	echo -n "" > "$(_get_package_database_path)"
	return 0
}

# add_entries_to_package_database()
# purpose: adds package entries to the package database
# input  : package entries in list format, delimeted by "|" characters
# output : -
add_entries_to_package_database() {
	cat >> "$(_get_package_database_path)"
}

# get_package_entries()
# purpose: locates package entries by name, architecture and repository
# input  : the package name, architecture and repository
# output : matching package entries
get_package_entries() {
	awk -v name="$1" \
	    -v arch="$2" \
	    -v repo="$3" \
	    -v distro_version="$(get_current_distro_version)" \
	    -F \|
	    '{
	        	if (name == $1 &&
	        	    arch == $4 &&
	        	    distro_version == $8 &&
	        	    repo == $9)
	        		print
	    }' "$(_get_package_database_path)"
}

##########################
# package entry routines #
##########################

# get_package_path()
# purpose: returns a package's path within a repository
# input  : a package entry
# output : the package path field
get_package_path() {
	echo "$1" | cut -f 5 -d \|
}

# get_package_file_name()
# purpose: returns a package's base file name
# input  : a package entry
# output : the package base file name
get_package_file_name() {
	package_path="$(get_package_path "$1")"
	echo "${package_path##*/}"
}

# get_package_repository()
# purpose: returns a package's repository
# input  : a package entry
# output : the package repository field
get_package_repository() {
	echo "${1##*|}"
}

#########################
# package list routines #
#########################

# get_package_list()
# purpose: returns the package list
# input  : -
# output : the package list
get_package_list() {
	# filter comments and empty lines
	echo "$DISTRO_PACKAGES" | grep -v -e ^# -e ^\$
}

# get_meta_package_name()
# purpose: returns the name field of a meta-package entry
# input  : a meta-package entry
# output : the meta package name
get_meta_package_name() {
	echo "${1%%|*}"
}

# get_meta_package_names()
# purpose: returns all meta-package names
# input  : -
# output : all meta package names
get_meta_package_names() {
	get_package_list | cut -f 1 -d \|
}
# get_meta_package_distro()
# purpose: receives a meta-package entry and returns the distribution fields
# input  :  a meta-package entry
# output : the distribution name, version and architecture
get_meta_package_distro() {
	echo "$1" | cut -f 3-5 -d \| | sed s/\|/\ /g
}

# get_meta_package_packages()
# purpose: lists the packages contained in a meta-package
# input  : a meta-package entry
# output : a list of the packages contained within the meta-package
get_meta_package_packages() {
	echo "$1" | cut -f 2 -d \| | sed s/,/\ /g
}

# get_used_distros()
# purpose: determines which distributions are used in the package list
# input  : -
# output : a list of distributions (name, version and architecture) used in the
#          package list
get_used_distros() {
	# do not use get_meta_package_distro() - invoking both cut and sed is slow
	get_package_list | awk -F \| '{print $3" "$4" "$5}' | sort | uniq
}

#########################
# repository processing #
#########################

# _add_repository_to_package_database()
# purpose: downloads a repository's package list and adds all package entries to
#          the package database
# input  : the repository name
# output : -
_add_repository_to_package_database() {
	# get the package list URL
	url="$(get_repository_package_list_url $1)"
	[ -z "$url" ] && return 1

	# create a temporary file
	package_list="$(mktemp -u)"

	# download the package list
	download_package_list "$url" "$package_list"
	[ 0 -ne $? ] && return 1

	# convert the package list to the common format, then add all entries to
	# the package database
	convert_package_list "$package_list" $1	| \
	sort | \
	add_entries_to_package_database

	# clean up
	rm -f "$package_list"
	[ 0 -ne $? ] && return 1

	return 0
}
# _add_distro_to_package_database()
# purpose: adds all package lists of the current distribution's repositories to
#          the package database
# input  : -
# output : -
_add_distro_to_package_database() {
	for repository in $(get_repository_names)
	do
		_add_repository_to_package_database $repository
		[ 0 -ne $? ] && return 1
	done
	return 0
}

# add_distros_to_package_database()
# purpose: downloads and processes the package lists of all repositories, for
#          each used distribution
# input  : -
# output : -
add_distros_to_package_database() {
	# create an empty package database
	initialize_package_database
	[ 0 -ne $? ] && return 1

	get_used_distros | while read distro
	do
		echo "$distro"

		# set the current distribution
		set_current_distro $distro
		[ 0 -ne $? ] && return 1

		# process the distribution's repositories
		_add_distro_to_package_database
		[ 0 -ne $? ] && return 1
	done

	return 0
}

##################
# package search #
##################

# find_package()
# purpose: the interface for searching the package database; finds the most
#          appropriate package entry
# input  : a package name
# output : the most appropriate entry for the package
find_package() {
	repositories="$(get_repository_names)"
	architectures="$(get_architecture_aliases $(get_current_distro_arch))"

	# try each repository, using all architecture aliases
	for repository in $repositories
	do
		for architecture in $architectures
		do
			result="$(get_package_entries $1 \
			                              $architecture \
			                              $repository)"
			[ -z "$result" ] && continue
			echo "$result" | tail -n 1
			return
		done
	done

	print_error "failed to locate the package \"$1\""
}

###############################
# configuration sanity checks #
###############################

# verify_configuration()
# purpose: verifies that the configuration is sane
# input  : -
# output : -
verify_configuration() {
	get_used_distros | while read distro
	do
		# set the current distribution
		set_current_distro $distro
		if [ 0 -ne $? ]
		then
			print_error "an invalid distribution was specified: $distro"
			return 1
		fi
	done

	return 0
}

####################
# package download #
####################

# _get_mirrors_for_repository()
# purpose: returns a list of all mirrors for a given repository
# input  : a repository name
# output : a list of mirror URLs
_get_mirrors_for_repository() {
	# for each mirror, filter the mirror URL and the list of repositories it
	# mirrors
	for mirror in $(get_repository_mirrors)
	do
		url="${mirror%%|*}"
		repositories="${mirror##*|}"

		# if the repository is mirrored, print the mirror URL
		for repository in $(echo $repositories | sed s/,/\ /g)
		do
			[ "$repository" != "$1" ] && continue
			echo "$url"
			break
		done
	done
}

# _get_package_download_url()
# purpose: returns download URLs for a given package
# input  : a package entry
# output : download URLs for the package
_get_package_download_url() {
	# get the package path within a repository
	package_path="$(get_package_path "$1")"

	# get the repository the package came from
	package_repository="$(get_package_repository "$1")"

	# for each mirror of the package's repository, create a full URL
	for mirror in $(_get_mirrors_for_repository $package_repository)
	do
		echo "$mirror/$package_path"
	done
}

# _download_package()
# purpose: downloads a package
# input  : the package name
# output : -
_download_package() {
	# locate the package entry
	package_entry="$(find_package $1)"
	if [ -z "$package_entry" ]
	then
		print_error "failed to locate $1"
		return 1
	fi

	# filter the package's base file name
	package_file_name="$(get_package_file_name "$package_entry")"

	# if the package exists already, do nothing
	[ -f "$VAR_PREFIX/package/$package_file_name" ] && return 0

	# otherwise, download the package
	[ ! -d "$VAR_PREFIX/package" ] && mkdir "$VAR_PREFIX/package"
	download_file "$(_get_package_download_url "$package_entry")" \
	              "$VAR_PREFIX/package/$package_file_name"
	if [ 0 -ne $? ]
	then
		print_error "failed to download $package_file_name"
		return 1
	fi

	return 0
}

# download_packages()
# purpose: a wrapper around _download_package() which downloads all packages
#          specified in the package list
# input  : -
# output : -
download_packages() {
	# for each meta-package, switch to its distribution and download all
	# packages
	get_package_list | while read entry
	do
		name="$(get_meta_package_name "$entry")"
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# if the meta-package was already extracted, end here - all packages
		# were downloaded already, of course; this saves the long process of
		# locating their package entries
		[ -d "$VAR_PREFIX/extracted_package/$name" ] && continue

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# download the packages
		for package in $packages
		do
			echo "$package"
			_download_package $package
			[ 0 -ne $? ] && return 1
		done
	done

	return 0
}

######################
# package extraction #
######################

# _apply_package_template()
# purpose: applies a package template on an extracted package
# input  : a package name and the path to the extracted package contents
#          directory
# output : -
_apply_package_template() {
	# if no package template exists, do nothing
	[ ! -d "$INSTALL_PREFIX/package-templates/$1" ] && return 0

	echo "  applying $INSTALL_PREFIX/package-templates/$1"

	# otherwise, copy the package template into the extracted package directory
	cp -ar "$INSTALL_PREFIX/package-templates/$1"/* "$2"
	[ 0 -ne $? ] && return 1

	# if a hacks script exists, run it
	[ ! -f "$2/$PACKAGE_TEMPLATE_HACKS_FILE_NAME" ] && return 0
	execute_and_delete_script "$2/$PACKAGE_TEMPLATE_HACKS_FILE_NAME"
	return $?
}

# extract_packages()
# purpose: a wrapper around extract_package() which extracts all packages
#          downloaded by download_packages()
# input  : -
# output : -
extract_packages() {
	get_package_list | while read entry
	do
		# get the meta-package name
		name="$(get_meta_package_name "$entry")"

		echo "$name"

		# get the meta-package's source distribution and the packages
		# contained in it
		packages="$(get_meta_package_packages "$entry")"
		distribution="$(get_meta_package_distro "$entry")"

		# set the current distribution
		set_current_distro $distribution
		[ 0 -ne $? ] && return 1

		# if the output directory exists, skip the meta-package
		[ -d "$VAR_PREFIX/extracted_package/$name" ] && continue

		# otherwise, create it
		mkdir -p "$VAR_PREFIX/extracted_package/$name"
		[ 0 -ne $? ] && return 1

		# extract all packages
		for package in $packages
		do
			echo "  $package"

			# locate the package
			entry="$(find_package $package)"
			[ -z "$entry" ] && return 1

			# filter the package base file name
			file_name="$(get_package_file_name "$entry")"

			# extract the package
			extract_package "$VAR_PREFIX/package/$file_name" \
			                "$VAR_PREFIX/extracted_package/$name"
			if [ 0 -ne $? ]
			then
				print_error "failed to extract $file_name"
				return 1
			fi
		done

		# apply the package template, if there is any
		_apply_package_template $name "$VAR_PREFIX/extracted_package/$name"
		[ 0 -ne $? ] && return 1
	done

	return 0
}

#####################################
# bootable media image construction #
#####################################

# _build_module()
# purpose: builds a module of the bootable media image
# input  : the module name, destination directory and the list of packages
# output : -
_build_module() {
	echo "$1"

	# create the destination directory
	if [ ! -d "$2" ]
	then
		mkdir "$2"
		[ 0 -ne $? ] && return 1
	fi

	# create a temporary file which will contain the post-installation script
	post_install="$(mktemp -u -p "$2")"

	(
		# add the module's skeleton
		echo "$INSTALL_PREFIX/skeleton/$1"

		# create a list of all package directories
		for package in $3
		do
			echo "$VAR_PREFIX/extracted_package/$package"
		done
	) | while read path
	do
		echo "  $path"

		# copy the contents of each directory to the destination
		cp -L -a --remove-destination "$path"/* "$2"
		[ 0 -ne $? ] && return 1

		# if a post-installation script exists, merge it with the previous ones
		[ ! -f "$2/$POST_INSTALL_SCRIPT_FILE_NAME" ] && continue
		cat "$2/$POST_INSTALL_SCRIPT_FILE_NAME" >> "$post_install"
		echo >> "$post_install"
		rm -f "$2/$POST_INSTALL_SCRIPT_FILE_NAME"
		[ 0 -ne $? ] && return 1
	done

	# remove .gitignore files
	find "$2" -name .gitignore -type f -delete
	[ 0 -ne $? ] && return 1

	# if at least one post-installation script exists, run it
	[ ! -f "$post_install" ] && return 0
	execute_and_delete_script "$post_install"
	return $?
}

# _build_initramfs()
# purpose: builds the initramfs
# input  : the extracted initramfs contents directory and the destination path
# output : -
_build_initramfs() {
	# copy the initramfs skeleton
	_build_module "initramfs" "$1" ""
	if [ 0 -ne $? ]
	then
		print_error "failed to build the initramfs"
		return 1
	fi

	# add BusyBox to the initramfs
	install -D -m 4755 "$BUSYBOX_PATH" "$1/bin/busybox"
	if [ 0 -ne $? ]
	then
		print_error "failed to build the initramfs"
		return 1
	fi

	# create and compress the initramfs
	cd "$1"
	find . | cpio -o -H newc | gzip $GZIP_OPTIONS > "$2"
	exit_code=$?
	cd "$BASE_DIR"
	if [ 0 -ne $? ]
	then
		print_error "failed to create the initramfs"
		return 1
	fi

	# if AdvanceCOMP is installed, recompress the initramfs
	[ -z "$(which advdef)" ] && return 0
	advdef -z4 "$2"
	if [ 0 -ne $? ]
	then
		print_error "failed to recompress the initramfs"
		return 1
	fi

	return 0
}

# _build_rootfs()
# purpose: builds the root file system Squashfs image
# input  : the extracted root file system contents directory and the destination
#          path
# output : -
_build_rootfs() {
	# copy roar-ng's configuration to the root file system
	install -D -m 644 "$CONFIGURATION_PATH" "$1/$CONFIGURATION_INSTALL_PATH"
	[ 0 -ne $? ] && return 1

	# copy the root file system packages and skeleton
	_build_module "rootfs" "$1" "$(get_meta_package_names)"
	if [ 0 -ne $? ]
	then
		print_error "failed to build the root file system"
		return 1
	fi

	# create /etc/hostname
	echo -n "$DISTRO_NICKNAME" > "$1/etc/hostname"

	# replace DISTRO_NAME and DISTRO_VERSION with their values, in /etc/issue
	# and /etc/motd
	for i in issue motd
	do
		sed -e s~DISTRO_NAME~"$DISTRO_NAME"~g \
		    -e s~DISTRO_VERSION~"$DISTRO_VERSION"~g \
		    -i "$1/etc/$i"
	done

	# populate /root with the home directory skeleton
	[ -d "$1/root" ] && rm -rf "$1/root"
	cp -a "$1/etc/skel" "$1/root"
	chown -R 0:0 "$1/root"
	chmod 600 "$1/root"
	[ 0 -ne $? ] && return 1

	# create a Squashfs image
	mksquashfs "$1" "$2" $MKSQUASHFS_OPTIONS
	if [ 0 -ne $? ]
	then
		print_error "failed to create the root file system image"
		return 1
	fi

	return 0
}

# build_bootable_media_image()
# purpose: builds a bootable media image
# input  : the bootable media type and the output file path
# output : -
build_bootable_media_image() {
	# make sure the given media is supported
	[ ! -f "$INSTALL_PREFIX/media/$1" ] && return 1

	# create a root directory for the bootable media contents
	if [ -d "$VAR_PREFIX/media" ]
	then
		rm -rf "$VAR_PREFIX/media"/*
		[ 0 -ne $? ] && return 1
	else
		mkdir "$VAR_PREFIX/media"
		[ 0 -ne $? ] && return 1
	fi

	# create /boot
	mkdir "$VAR_PREFIX/media/boot"
	[ 0 -ne $? ] && return 1

	# build the root file system image
	_build_rootfs "$VAR_PREFIX/rootfs" \
	              "$VAR_PREFIX/media/boot/$ROOT_FS_FILE_NAME"
	[ 0 -ne $? ] && return 1

	# build the initramfs
	_build_initramfs "$VAR_PREFIX/initramfs" \
	                 "$VAR_PREFIX/media/boot/$INITRAMFS_FILE_NAME"
	[ 0 -ne $? ] && return 1

	# move the kernel image from the root file system to the media itself
	mv -f "$VAR_PREFIX/rootfs/$KERNEL_IMAGE_PATH" \
	      "$VAR_PREFIX/media/$KERNEL_IMAGE_PATH"

	# build a bootable media image
	. "$INSTALL_PREFIX/media/$1"
	build_media_$1 "$VAR_PREFIX/media" "$2"
	if [ 0 -ne $? ]
	then
		print_error "failed to create the bootable media image"
		return 1
	fi

	return 0
}

# _set_up_chroot()
# purpose: sets up a chroot environment within a built distribution
# input  : the root file system path
# output : -
_set_up_chroot() {
	# bind all virtual file systems
	for i in $CHROOT_VIRTUAL_FS
	do
		mount --bind /$i "$1/$i"
		[ 0 -ne $? ] && return 1
	done

	# copy required files into the chroot environment
	for i in $CHROOT_FILES
	do
		cp /$i "$1/$i"
		[ 0 -ne $? ] && return 1
	done

	return 0
}

# _clean_up_chroot()
# purpose: cleans up the chroot environment created using _set_up_chroot()
# input  : the root file system path
# output : -
_clean_up_chroot() {
	# assume everything succeeds
	is_success=1

	# unbind all virtual file systems
	for i in $CHROOT_VIRTUAL_FS
	do
		# if no file system is mounted - the binding loop was stopped due a
		# failure - just try to unbind the next
		mountpoint -q "$1/$i"
		[ 1 -eq $? ] && continue

		umount "$1/$i"
		[ 0 -ne $? ] && is_success=0
	done

	[ 0 -eq $is_success ] && return 1
	return 0
}

# _build_package()
# purpose: builds a package within the result distribution; must run after
#          _set_up_chroot()
# input  : the chroot environment path and the package name
# output : -
_build_package() {
	# create a temporary directory for the building operation
	build_dir="$(mktemp -d -p "$1/$BUILD_PREFIX" "$2XXXXXX" | sed s~"$1"~~)"

	# if the sources were downloaded already, copy them to the build directory
	if [ -d "$VAR_PREFIX/source/$2" ]
	then
		cp -f "$VAR_PREFIX/source/$2"/* "$1/$build_dir"
		[ 0 -ne $? ] && return 1
	else
		mkdir -p "$VAR_PREFIX/source/$2"
		[ 0 -ne $? ] && return 1
	fi

	# call buildpkg to download the package sources
	chroot "$1" \
	       /bin/sh -c "cd $build_dir; /usr/sbin/buildpkg download /var/packages/$2.sh"
	[ 0 -ne $? ] && return 1

	# copy the sources to the sources directory, so they don't have to be
	# downloaded again next time
	cp -f "$1/$build_dir"/* "$VAR_PREFIX/source/$2"
	[ 0 -ne $? ] && return 1

	# build the package
	chroot "$1" \
	       /bin/sh -c "cd $build_dir; /usr/sbin/buildpkg build /var/packages/$2.sh"
	[ 0 -ne $? ] && return 1

	# if the package was already built, remove the old build
	if [ -e "$1/$BUILD_RESULT_PREFIX/$2" ]
	then
		rm -rf "$1/$BUILD_RESULT_PREFIX/$2"
		[ 0 -ne $? ] && return 1
	fi

	# if the compilation succeeded, move the directory to the build results
	# directory
	mv "$1/$build_dir" "$1/$BUILD_RESULT_PREFIX/$2"
	[ 0 -ne $? ] && return 1

	# copy the package to the binary packages directory
	cp -f "$1/$BUILD_RESULT_PREFIX/$2"/*.rxz "$VAR_PREFIX/package"
	[ 0 -ne $? ] && return 1

	# install the package within the chroot environment, using hpm
	chroot "$1" /bin/sh -c "hpm-install /$BUILD_RESULT_PREFIX/$2/*.rxz $2"
	[ 0 -ne $? ] && return 1

	return 0
}

# _show_usage()
# purpose: shows the usage message and exits
# input  : -
# output : -
_show_usage() {
	echo "$USAGE"
	exit 1
}

# roar_ng_main()
# purpose: runs roar-ng
# input  : -
# output : the command-line arguments the script was executed with
roar_ng_main() {
	case "$1" in
		check)
			[ 1 -ne $# ] && _show_usage
			verify_configuration
			exit $?
			;;

		setup)
			[ 1 -ne $# ] && _show_usage
			add_distros_to_package_database
			exit $?
			;;

		download)
			[ 1 -ne $# ] && _show_usage
			download_packages
			exit $?
			;;

		extract)
			[ 1 -ne $# ] && _show_usage
			extract_packages
			exit $?
			;;

		build)
			[ 3 -ne $# ] && _show_usage
			build_bootable_media_image "$2" "$3"
			exit $?
			;;

		package)
			[ 2 -ne $# ] && _show_usage

			# make sure there is a build script for the specified package
			[ ! -f "$INSTALL_PREFIX/skeleton/rootfs/var/packages/$2.sh" ] && \
			                                                         _show_usage

			# prepare a chroot environment
			_set_up_chroot "$VAR_PREFIX/rootfs"
			if [ 0 -ne $? ]
			then
				print_error "failed to set up a chroot environment"
				exit 1
			fi

			# attempt to build the package
			_build_package "$VAR_PREFIX/rootfs" "$2"
			exit_code=$?

			# clean up
			_clean_up_chroot "$VAR_PREFIX/rootfs"
			if [ 0 -ne $? ]
			then
				print_error "failed to clean up the chroot environment"
				exit 1
			fi

			if [ 0 -ne $exit_code ]
			then
				print_error "failed to build $2"
				exit 1
			else
				exit 0
			fi
			;;

		cleanup)
			for i in initramfs rootfs media
			do
				[ ! -d "$VAR_PREFIX/$i" ] && continue
				echo "$i"
				rm -rf "$VAR_PREFIX/$i"
				if [ 0 -ne $? ]
				then
					print_error "failed to remove $VAR_PREFIX/$i"
					exit 1
				fi
			done

			exit 0
			;;

		*)
			_show_usage
			;;
	esac
}

# if the script was invoked as "roar-ng", run the script's main logic;
# otherwise, do nothing, to allow the script to be included in other scripts
case "$0 $@" in
	"roar-ng "*|*" roar-ng "*|*"/roar-ng "*)
		roar_ng_main "$@"
		;;
esac
