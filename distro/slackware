# determine whether to use "slackware" or "slackware64"
suffix=""
case $(get_current_distro_arch) in
	*64)
		suffix="64"
		;;
esac

# repositories - package list URL|repository name
REPOSITORIES="ftp://ftp.osuosl.org/pub/slackware/slackware$suffix-$(get_current_distro_version)/patches/PACKAGES.TXT|slackware-patches
              ftp://ftp.osuosl.org/pub/slackware/slackware$suffix-$(get_current_distro_version)/PACKAGES.TXT|slackware-main"

# package download mirrors
MIRRORS="ftp://ftp.gwdg.de/pub/linux/slackware/slackware$suffix-$(get_current_distro_version)|slackware-main,slackware-patches
         ftp://ftp.fu-berlin.de/unix/linux/mirrors/slackware/slackware$suffix-$(get_current_distro_version)|slackware-main,slackware-patches
         http://ftp.gwdg.de/pub/linux/slackware/slackware$suffix-$(get_current_distro_version)|slackware-main,slackware-patches
         http://slackware.mirrors.tds.net/pub/slackware/slackware$suffix-$(get_current_distro_version)|slackware-main,slackware-patches"

# slackware_get_architecture_aliases()
# purpose: translates an architecture name to the distribution's nicknames
# input  : an architecture name
# output : the distribution's names for the architecture, ordered by accuracy
slackware_get_architecture_aliases() {
	case "$1" in
		x86_64|amd64)
			echo "x86_64 noarch x86"
			;;
		x86|i?86)
			echo "i486 noarch x86"
			;;
	esac
}

# slackware_download_package_list()
# purpose: downloads the distribution's package list
# input  : the package list URL and the destination path
# output : -
slackware_download_package_list() {
	download_file "$1" "$2"
}

# slackware_convert_package_list()
# purpose: converts a repository's package list to roar-ng's common format
# input  : the package list path and the repository name
# output : a package list in roar-ng's format
slackware_convert_package_list() {
	awk -v distro="$(get_current_distro)" \
	    -v distro_version="$(get_current_distro_version)" \
	    -v repo="$2" \
	    -F ":" '

	    # trims the beginning of a string
	    function trim(s) {
	    	sub(/^ */, "", s);
	    	return s
	    }

	    # prints a package list entry
	    function print_entry() {
	    	# split the name by "-"
	    	name_items = split(file_name, name, "-");

	    	# check if there are enough fields
	    	if (3 < name_items) {
	    		# strip the extension
	    		sub(/\..*/, "", name[name_items]);
	    		revision = name[name_items];

	    		# filter the version
	    		version = name[name_items - 2];

	    		# filter the architecture
	    		arch = name[name_items - 1];

	    		# add the rest of the fields to the package name and
	    		# remove the "-" at the beginning
	    		for (i = 1; name_items - 2 > i; i++) {
	    			package_name = package_name"-"name[i]
	    		}
	    		sub(/^-/, "", package_name)
	    		printf("%s|%s|%s|%s|%s/%s|%s|%s|%s|%s\n",
	    		       package_name,
	    		       version,
	    		       revision,
	    		       arch,
	    		       path,
	    		       file_name,
	    		       description,
	    		       distro,
	    		       distro_version,
	    		       repo);
	    		package_name = "";
	    		file_name = ""
	    	}
	    }
	    {
	    	if ($1 == "PACKAGE NAME") {
	    		file_name = trim($2);
	    	} else {
	    		if ($1 == "PACKAGE LOCATION") {
	    			path = trim($2);
	    			# trim and strip "./"
	    			sub(/^\.\//, "", path)
	    		} else {
	    			if ($1 == "PACKAGE DESCRIPTION") {
	    				getline description;
	    				description = trim(description);
	    				sub(/[^:]*: +/, "", description);
	    			} else {

	    				# when the empty line separator is
	    				# reached, print the current entry
	    				if ("" == $0 && "" != file_name) {
	    					print_entry()
	    				}
	    			}
	    		}
	    	}
	    } END {
	    	# when the end of the file is reached, print the current entry
	    	if ("" != file_name) {
	    		print_entry()
	    	}
	}' "$1"
}

# slackware_extract_package()
# purpose: extracts a package of the distribution into a directory
# input  : a package path and the destination directory
# output : -
slackware_extract_package() {
	# extract the package
	extract_tarball "$1" "$2"
	[ 0 -ne $? ] && return 1

	# if a post-installation script exists, run it
	if [ -f "$2/install/doinst.sh" ]
	then
		cd "$2"
		chmod 755 ./install/doinst.sh
		./install/doinst.sh
		cd "$BASE_DIR"
	fi

	# remove the package metadata
	rm -rf "$2/install"
	[ 0 -ne $? ] && return 1

	return 0
}
