# the relative path to repomd.xml, the repository index
REPOMD_PATH="repodata/repomd.xml"

# part of the package list file name
PACKAGE_LIST_NAME="primary.xml"

# repositories - package list URL|repository name; repositories are specified
# via their base path; this directory contains repodata/repomd.xml, with
# contains the variable name of the actual package list; see
# download_package_list
REPOSITORIES="http://centos.arcticnetwork.ca/$(get_current_distro_version)/updates/$(get_current_distro_arch)|centos-updates
              http://centos.arcticnetwork.ca/$(get_current_distro_version)/os/$(get_current_distro_arch)|centos-os"

# package download mirrors - more at http://www.centos.org/modules/tinycontent/index.php?id=30
MIRRORS="http://centos.arcticnetwork.ca/$(get_current_distro_version)/os/$(get_current_distro_arch)|centos-os
         http://centos.arcticnetwork.ca/$(get_current_distro_version)/updates/$(get_current_distro_arch)|centos-updates
         http://centos.fis.uniroma2.it/$(get_current_distro_version)/os/$(get_current_distro_arch)|centos-os
         http://centos.fis.uniroma2.it/$(get_current_distro_version)/updates/$(get_current_distro_arch)|centos-updates"

# centos_get_architecture_aliases()
# purpose: translates an architecture name to the distribution's nicknames
# input  : an architecture name
# output : the distribution's names for the architecture, ordered by accuracy
centos_get_architecture_aliases() {
	case "$1" in
		x86_64|amd64)
			echo "x86_64 noarch i686"
			;;
		# 32-bit packages for multilib systems are i686-optimized and contained
		# in the x86_64 repository
		i686)
			echo "i686 noarch"
			;;
		x86|i?86)
			echo "i386 noarch"
			;;
	esac
}

# centos_download_package_list()
# purpose: downloads the distribution's package list
# input  : the package list URL and the destination path
# output : -
centos_download_package_list() {
	# create a temporary file
	repomd="$(mktemp -u)"

	# download repomd.xml
	download_file "$1/$REPOMD_PATH" "$repomd"
	[ 0 -ne $? ] && return 1

	# filter the package list file name
	package_list_file_name="$(grep $PACKAGE_LIST_NAME $repomd | \
	                          cut -f 2 -d \")"

	# clean up
	rm -f $repomd

	# if the package list was not found, report error
	[ -z "$package_list_file_name" ] && return 1

	# download the package list
	download_file "$1/$package_list_file_name" "$2"
	[ 0 -ne $? ] && return 1

	# decompress the package list
	decompress_file "$2"
}

# centos_convert_package_list()
# purpose: converts a repository's package list to roar-ng's common format
# input  : the package list path and the repository name
# output : a package list in roar-ng's format
centos_convert_package_list() {
	awk -v distro="$(get_current_distro)" \
	    -v distro_version="$(get_current_distro_version)" \
	    -v repo="$2" '
	    BEGIN {
	    	RS = "<"
	    }

	    {
	    	if ($1 ~ "^name") {
	    		sub(/^name>/, "", $0);
	    		name = $0;
	    		names = name
	    	} else {
	    		if ($1 ~ "^arch") {
	    			sub(/^arch>/, "", $0);
	    			arch = $0
	    		} else {
	    			if ("version" == $1) {
	    				for (i = 2; NF >= i; i++) {
	    					value = $i

	    					# remove the attribute name and
	    					# the "="
	    					sub(/.*=\"/, "", value);

	    					# remove the trailing "\"/"
	    					sub(/\".*/, "", value);

	    					if ($i ~ "^ver") {
	    						version = value
	    					} else {
	    						if ($i ~ "^rel") {
	    							revision = value
	    						}
	    					}
	    				}
	    			} else {
	    				if ($1 ~ "^summary") {
	    					# strip the closing tag
	    					sub(/^summary>/, "", $0);
	    					description = $0
	    				} else {
	    					if ("location" == $1) {
	    						# remove the "href=\""
	    						sub(/.*href=\"/, "", $2);

	    						# remove the trailing quotes and
	    						# everything afterwards
	    						sub(/\".*/, "", $2);

	    						file_name = $2
	    					} else {
	    						if ("rpm:provides>" == $1) {
	    							# each alternate name is a child tag
	    							do {
	    								getline;
	    								if ("" == $2) {
	    									continue
	    								}
	    								split($2, entry_split, "\"");

	    								# if the alternate name is not the
	    								# package name, add it to the list
	    								if (name != entry_split[2]) {
	    									names = names","entry_split[2]
	    								}
	    							} while ("/rpm:provides>" != $1);
	    						} else {
	    							if ("rpm:requires>" == $1) {
	    								# each dependency is a child tag
	    								do {
	    									getline;
	    									if ("" == $2) {
	    										continue
	    									}
	    									split($2, dependency, "\"");
	    									dependencies = \
	    										  (dependencies","dependency[2])
	    								} while ("/rpm:requires>" != $1);

	    								# remove the leading comma
	    								sub(/^,/, "", dependencies);
	    							} else {
	    								if ("/package>" == $1) {
	    									printf( \
	    									  "%s|%s|%s|%s|%s|%s|%s|%s|%s|%s\n",
	    									  names,
	    									  version,
	    									  revision,
	    									  arch,
	    									  file_name,
	    									  description,
	    									  distro,
	    									  distro_version,
	    									  repo,
	    									  dependencies);
	    									dependencies = ""
	    								}
	    							}
	    						}
	    					}
	    				}
	    			}
	    		}
	    	}
	    }' "$1"
}

# centos_extract_package()
# purpose: extracts a package of the distribution into a directory
# input  : a package path and the destination directory
# output : -
centos_extract_package() {
	# extract the package
	cd "$2"
	rpm2cpio "$1" | cpio -id
	exit_code=$?
	cd "$BASE_DIR"

	[ 0 -ne $exit_code ] && return 1
	return 0
}
